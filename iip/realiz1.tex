\chapter{Реализация}

Реализация игры разделена на несколько модулей, как и описано выше. 

Ссылка на листинги см. в приложениях.

\section{Классы}

\subsection*{Класс Bitboard}

Как уже было сказано, этот класс построен на основе \texttt{std::bitset}. Он имеет следующие основные методы:
\begin{description}
	\item[\texttt{test}] проверяет, является ли бит единицей
	\item[\texttt{set}] делает бит единицей
	\item[\texttt{reset}] делает бит нулём
	\item[\texttt{count}] считает количество единиц
	\item[\texttt{find\_first}] ищет первую единицу
	\item[\texttt{find\_last}] ищет последнюю единицу
\end{description}

Они в основном полагаются на уже встроенные методы \texttt{std::bitset}, кроме \texttt{find\_first} и \texttt{find\_last}: они используют скан-таблицу[5].

Имеются также некоторые вспомогательные методы (битовых операций и ввода-вывода).

\subsection*{Класс Board}

Также реализует сказанное выше: 12 битовых досок на каждый тип фигур каждого цвета, 2 на сторону, 2 на пустые клетки сторон, доски для занятых и свободных клеток. 

Метод \texttt{update} обновляет вспомогательные доски.

\subsection*{Класс Hash}

Реализация хеширования (содержит поле с хешем доски). Использует заранее сгенерированные генератором константы для обозначения фигур на позициях, добавляя или удаляя при вызове функции \texttt{put\_piece}. При этом используется тождество $a\oplus a = 0$.

\subsection*{Класс Move}

Этот класс хранит в себе ход. Он содержит несколько полей (откуда, куда, тип и цвет фигуры, съеденную фигуру, флаги продвижения). 

\subsection*{Класс RecentHistory}

Этот класс содержит в себе историю последних ходов. Это нужно для реализации правила 3-х ходов. Строится на основе \texttt{std::unordered\_map}. Позволяет узнавать количество повторов по хешу позиции. Очищается при взятии или продвижении.

\subsection*{Класс Position}

Хранит текущую позицию: доску, счетчики ходов, хеш, историю ходов. 

Основной метод --- \texttt{apply\_move}: применяет ход, описываемый в классе Move.

\subsection*{Класс PseudoLegalMoveMaskGen}

Этот класс генерирует битовые маски движения для всех фигур, с учетом правил ходов (кроме шахов и других подобных). Отдельно генерируются взятия пешками. К сожалению, в этом классе есть несколько не очень эффективных методов, однако, это не сильно влияет на производительность.

Здесь же находится функция \texttt{in\_danger}, проверяющая, не бьётся ли какая-либо фигура другими. Для этого генерируются все маски из данной позиции и проверяется, не находятся ли там фигуры, которые могут съесть данную.

\subsection*{Класс MoveList}

Этот класс хранит в себе список возможных ходов от генератора. В остальном схож с массивом (имеет методы \texttt{[]}, \texttt{push\_back}, \texttt{size}).

\subsection*{Класс LegalMoveGen}

Этот класс генерирует ходы на основе ранее созданных масок. Делается это так: из маски при помощи \texttt{find\_last} достается следующий ход. Он проверяется на правильность (король не окажется под ударом) и записывается в список ходов \texttt{MoveList}. Имеется возможность генерировать только взятия.

\subsection*{Класс Static}

Этот класс реализует оценку позиции как было сказано выше. Для получения оценки вызывается функция \texttt{evaluate}.

\subsection*{Класс Human}

Это интерфейс взаимодействия игрока и игры (т.е. получения от него хода). Считывается ход игрока (в формате \textbf{e2e3}, откуда (\textbf{е2}) --- куда(\textbf{е3})). Если ход содержит продвижение, то спрашивается, какое именно.

\subsection*{Класс AI}

В этом классе содержится вышеупомянутый алгоритм поиска.  Однако здесь имеются некоторые интересные особенности.

Алгоритм альфа-бета запускается в отдельном потоке --- так можно настроить время (а значит и глубину) поиска. По истечении времени взводится флаг остановки, и поиск прекращается. Возвращаемое значение --- оценка и ход.

Циклом жестко задаётся глубина основного поиска. Когда алгоритм достигает этой глубины, запускается <<облегчённый>> алгоритм, учитывающий только взятия и возвращающий только оценку.