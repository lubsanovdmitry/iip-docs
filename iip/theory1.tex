{

	\chapter{Обзор и теория}
	\section{Используемые технологии}
	Создание движка будет вестись на языке С++. Это мощный и  популярный язык для разработки настольных приложений.
	
	Разработка будет вестись в среде CLion от компании JetBrains. Она также является популярной, имеет широкий набор возможностей. Кроме того, производитель предоставляет бесплатные лицензии учащимся. 
	
	Компилятором является GNU G++ 12.2, а системой сборки --- CMake 3.26. Они оба имеют открытый исходный код и бесплатны. Проект создан при помощи дополнения cmake-init.
	
	Для управления терминальным выводом используется библиотека rang[6].
	
	\section{Обзор игры}
	
	Как уже было сказано, шатар --- это разновидность шахмат, и большинство правил схожи с европейскими шахматами. Так что имеет смысл описать различия.
	На самом деле, степень отличия может варьироваться, ведь среди шатар тоже встречаются разные варианты. 
	
	Возьмём такую версию[2][8]:
	
	\begin{itemize}
		\item Отсутствует рокировка;
		\item Пешка не может совершать двойное перемещение, кроме случаев начала игры. Таким образом, отсутствует взятие на проходе;
		\item В начале игры обязательно совершаются ходы d2d4 и d7d5 (можно считать это начальным состоянием игры);
		\item  Ферзь может ходить только на одно поле по диагонали.
	\end{itemize}
	
	\section{Шахматный движок}
	
	Шахматный движок --- программа, переносящая игру в шахматы в форму компьютерной программы. Движки также обычно содержат в себе некий алгоритм, способный играть в шахматы.
	
	Тогда шахматный движок как бы состоит из двух частей: шахматной доски и алгоритма игры (условно --- искусственного интеллекта, ИИ), который, в свою очередь, состоит из механизмов \textit{оценки} и \textit{поиска}.
	
	\subsection{Шахматная доска}
	
	Существует множество способов представления шахматной доски[6] --- например, можно было бы использовать <<наивный>>: создадим массив размером 8х8, в каждой ячейке которого находится некая фигура. Ещё лучше будет создать доску размером 10х12, тогда удобнее будет обработать фигуры, которые могут выйти за пределы поля.
	
	Однако, уже давно существует более удобный (в первую очередь для компьютера) способ, использующий т.н. <<битовые доски>> (англ. \textit{bitboards})[5]. Его достоинства в том, что требуется меньше памяти, а также увеличивается скорость (за счёт использования встроенных операций). Так, можно сгенерировать ходы для пешек просто произведя побитовый сдвиг. Многие операции можно очень быстро выполнять --- за $\mathcal{O}(1)$.
	
	Назовём \textit{битовой доской} двоичное число длины 64, \textit{i}-й бит которого обозначает, находится ли в позиции \textit{i} какая-либо фигура.
	
	Для удобства отметим, что нумерация битов начинается со старшего (most significant) бита. Тогда получится такое соответствие квадратам доски:
	
	%\vspace{1em}
	
	
	\begin{table}[h]
		\centering
		\caption{Соответствие}
		\label{tab: accord}
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
			\hline
			  & A & B  & C  & D  & E  & F  & G  & H  \\ \hline
			8 & 0 & 8  & 16 & 24 & 32 & 40 & 48 & 56 \\ \hline
			7 & 1 & 9  & 17 & 25 & 33 & 41 & 49 & 57 \\ \hline
			6 & 2 & 10 & 18 & 26 & 34 & 42 & 50 & 58 \\ \hline
			5 & 3 & 11 & 19 & 27 & 35 & 43 & 51 & 59 \\ \hline
			4 & 4 & 12 & 20 & 28 & 36 & 44 & 52 & 60 \\ \hline
			3 & 5 & 13 & 21 & 29 & 37 & 45 & 53 & 61 \\ \hline
			2 & 6 & 14 & 22 & 30 & 38 & 46 & 54 & 62 \\ \hline
			1 & 7 & 15 & 23 & 31 & 39 & 47 & 55 & 63 \\ \hline
		\end{tabular}
	\end{table}
	
	Теперь шахматную доску можно представить как набор таких битовых досок --- по одной на каждый тип фигуры, ещё две, показывающие, какой стороне принадлежит фигура, а также --- общая, т.е. показывающая наличие или отсутствие фигуры на доске в принципе. К ним понадобятся ещё несколько вспомогательных (инвертированных).
	
	Реализовать битовые доски достаточно просто на основе \texttt{std::bitset}.
	
	Доска и счётчик ходов составляют \textit{позицию}.
	
	Нам потребуется следить за повторяющимися позициями. Можно, конечно, хранить каждую позицию по отдельности, но это достаточно затратно. Поэтому можно каждую позицию \textit{хешировать}, т.е. присвоить \textit{хеш}. Такой хеш называют Zobrist-хешем[6].
	
	Для того, чтобы совершать ходы, нужна некая структура, описывающая ход. Она содержит в себе собственно ход, то, какой фигурой сходили, съеденную фигуру (если таковая была), продвижение (если оно было).
	
	Требуется реализовать правила. Сделаем так: для каждой позиции сгенерируем все возможные легальные ходы (т.е. те, которые не нарушают правил игры). Теперь можно легко проверить ход на правильность, найдя его в списке возможных ходов.
	
	Позиция может быть инициализирована при помощи FEN-строки (строки в формате нотации Форсайта-Эдвардса --- нотации, описывающей шахматную позицию).
	
	\subsection{Оценка}
	 
	 Оценка --- это некоторое число, описывающее текущее состояние игры --- насколько близко тот или иной игрок к победе (или проигрышу). Очевидно, это требуется для того, чтобы алгоритм поиска понимал, какие ходы выгоднее, а какие --- нет. 
	 
	 Зачастую в данный момент времени невозможно сказать, кто выиграет. Но мы можем приблизительно понять, кто сейчас <<ведёт>>. Скажем, что если число \textit{меньше}, то игра идёт в пользу белых, а если оно \textit{больше} --- чёрных. 
	 
	 Из чего складывается эта оценка? Тут есть множество факторов, основные из них --- это
	 
	 \begin{itemize}
	 	\item Материал --- какие фигуры сейчас на доске,
	 	\item Мобильность --- сколько они бьют полей,
	 	\item Расположение фигур.
	 \end{itemize} 
 	
 	 Материал --- это сумма цен всех фигур на доске. Вот они [6]:
 	 
 	 	\begin{table}[h]
 	 	\centering
 	 	\caption{Цена фигуры}
 	 	\label{tab: material}
 	 	\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
 	 		\hline
 	 		Фигура & Цена \\ \hline
 	 		Пешка & 100 \\ \hline
 	 		Конь & 300 \\ \hline
 	 		Слон & 350  \\ \hline
 	 		Ладья & 500 \\ \hline
 	 		Ферзь & 900 \\ \hline
 	 		\end{tabular}
  		\end{table}
 		
	Считается, что Король имеет очень большое значение; здесь же это просто не учитывается.
	
	Мобильность рассчитывается из количества полей, которые бьют фигуры. За каждое поле даётся:
	
	\begin{table}[h]
		\centering
		\caption{Цена фигуры}
		\label{tab: mobility}
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|}
			\hline
			Фигура & Цена \\ 
			\hline
			Конь & 9 \\ 
			\hline
			Слон & 4  \\ 
			\hline
			Ладья & 3 \\ 
			\hline
			Ферзь & 3 \\ 
			\hline
		\end{tabular}
	\end{table}

	В положениях фигур учитываются только сдвоенные пешки (отнимает 25) и два слона (даёт 50). 
	
	Имеется особая оценка для эндшпиля: единица дистанции между королями и королём и центром даёт 10 очков.
	
   	\subsection{Алгоритм}
   	
   	Шахматы --- классическая игра для двух игроков. Мы можем оценить каждое состояние игры; оно меняется с каждым ходом. Теперь можно сказать, что для того, чтобы победить, белые хотят максимизировать оценку (а черные --- минимизировать). 
   	
   	Представим игру в виде дерева, где вершины --- это позиции игры с оценкой, а ребра --- ходы. Это есть \textit{игровое дерево} --- графическое представление процесса принятия решений в последовательности игры двух соперников. На графе можно воспользоваться \textit{поиском в глубину}: из каждой вершины-состояния мы проверим влияние на оценку всех ходов, пытаясь максимизировать или минимизировать оценку. Такой алгоритм называется \textit{максиминным}.
	
	Однако следует учесть, что коэффициент ветвления шахмат составляет около 35[6]. Таким образом, на каждой позиции мы имеем около 35 возможных ходов (хотя в начале и конце игры этот показатель может быть меньше, а середине --- больше). Для поиска на глубину $d$ ходов необходимо рассмотреть примерно $35^{d}$ позиций (т.е., например, на $8$ ходов --- $35^{8} \approx 2,25\cdot10^{12}$).
	
	Известно, что временная сложность алгоритма поиска в глубину составляет $\mathcal{O}(n+m)$, в нашем случае --- $\mathcal{O}(b^{d})$ ($b$ --- текущий коэффициент ветвления). Требуется оптимизация, иначе поиск займет слишком много времени.
	
	Можно совершить очень большое число ходов до того, как игра завершится. Так что ограничим глубину поиска.
	
	Другой важной оптимизацией будет сохранение значений позиций (чтобы не считать их каждый раз заново). Для этого можно воспользоваться хеш-таблицей (например, \texttt{std::unordered\_map}). Будем сохранять туда хеши и значения всех рассмотренных позиций, и при переходе проверять, не находится ли она в хеш-таблице.
	
	Но этого всё ещё недостаточно. Самой важной оптимизацией является применение \textit{альфа-бета отсечения}[9]. Оно просто в реализации и использует следующую идею: не имеет смысла рассматривать поддерево дальше, если мы не сможем добиться лучшей для нас оценки. Мы можем ограничить поиск определённым диапазоном $[\alpha;\beta]$, определяемым динамически. Это позволяет ускорить алгоритм до (в лучшем случае) $\mathcal{O}(\sqrt{b^{d}})$.
	
	
}